# 字符数组和字符串

## 把字符串赋值给字符数组

Delphi 有两个函数可以干这个事：
**StrCopy**  
**StrLCopy**  

上述两个函数，针对 UNICODE 字符和 Ansi 字符又有两种：  
**System.AnsiStrings.StrCopy**  
~~~
function StrCopy(Dest: PAnsiChar; const Source: PAnsiChar): PAnsiChar;
~~~
  
**System.SysUtils.StrCopy**  
~~~
function StrCopy(Dest: PWideChar; const Source: PWideChar): PWideChar;
~~~

**System.SysUtils.StrLCopy**  
~~~
function StrLCopy(Dest: MarshaledAString; const Source: MarshaledAString; MaxLen: Cardinal): MarshaledAString; overload;
function StrLCopy(Dest: PWideChar; const Source: PWideChar; MaxLen: Cardinal): PWideChar;
~~~

**System.AnsiStrings.StrLCopy**  
~~~
function StrLCopy(Dest: PAnsiChar; const Source: PAnsiChar; MaxLen: Cardinal): PAnsiChar;
~~~

### StrCopy 和 StrLCopy 的区别
1. StrCopy 不考虑长度。因此，必须自己处理长度。如果目标的长度和源的长度不一致，则必须取小的那个，避免长度超出。取小的那个，可以使用 Min 函数；
2. StrLCopy 对长度做了管理。并且会在拷贝字符串时，给目标加上  null terminator ，因此，这里的长度**MaxLen**必须是目标长度 -1（给结尾的 null terminator 保留一个位置）；

Help 里面说：StrLCopy copies a maximum of MaxLen characters from Source to Dest, adds a null terminator to Dest and returns Dest. Keep in mind that you need to provide a large enough Dest to accommodate the null terminator. For example, you can specify MaxLen as Length(Dest) - 1. 

### 简单的例子代码：
~~~
var 
  A: array[0..9] of AnsiChar;
  B: array[0..9] of Char;
  Sa, Sb: AnsiString;
  Sc, Sd: String;
~~~

##### 针对上述定义的变量，把字符串的值赋值给字符数组（Ansi 版本）：
~~~
  Sa := 'abcdEFG';
  StrLCopy(PAnsiChar(@(A)), PAnsiChar(Sa), Length(A) - 1);
  Sb := A;
~~~
因为 StrLCopy 的 Ansi 版本，里面的目的和源，都是 PAnsiChar，因此，对于 AnsiString 就直接强制类型转换 PAnsiChar(Sa)，对于 AnsiChar 数组，则需要取地址（也就是它的指针），再把它的指针强制类型转换为 PAnsiChar;  
最后的 Sb := A 则是直接把字符数组赋值给字符串。

##### 把字符串赋值给字符数组（Unicode 版本）：
~~~
  Sc := '双字节超过十个字符的时候';
  StrLCopy(PWideChar(@(B)), PWideChar(Sc), Length(B) - 1); //这里必须留一个 Char 作为结尾 0；所以长度要 -1
  Sd := B;
~~~
同 Ansi 版本，这里的目的和源，都是 PWideChar，因此要对字符数组和字符串做强制类型转换。最后的 Sd := B; 也没问题。

## Byte 数组
**array of Byte**  
**TArray<Byte>** 
**TBytes**  
**TIdBytes**  

上述几个不同类型的数组，底层的类型完全相同，都是**Kind: tkDynArray**。它们的内存布局相同，都是引用计数。
因此，可以直接使用强制类型转换赋值。这样的赋值是引用，因此修改了一个，其它引用的变量的值也会被修改；因为是引用计数，因此不需要主动释放。

例子代码
~~~
var
  A: TBytes;
  B: TIdBytes;
  C: Array of Byte;
  i: Integer;
begin
  SetLength(A, 10);
  for i := 0 to Length(A) -1 do
  begin
    A[i] := i + 1;
  end;

  B := TIdBytes(A); //强制类型转换没问题

  SetLength(C, 10);
  for i := 0 to Length(C) -1 do
  begin
    C[i] := i + 3;
  end; 
  A := C; //这样直接赋值没有问题。把 array of Byte 赋值给 TBytes。
end;
~~~

## 总结
1. 字符串要赋值给字符数组，必须使用 **StrLCopy** 函数；
2. 字符数组要赋值给字符串，直接赋值 S := C 的方式；
3. string 不能和 AnsiChar 之间使用上述 StrLCopy 函数；反过来 AnsiString 和 Char 之间也不能。